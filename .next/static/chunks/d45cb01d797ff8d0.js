(globalThis.TURBOPACK||(globalThis.TURBOPACK=[])).push(["object"==typeof document?document.currentScript:void 0,781690,e=>{"use strict";let t;var n=e.i(474076),i=e.i(574983);function r(e){return{formatters:void 0,fees:void 0,serializers:void 0,...e}}e.i(247167),r({id:"5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp",name:"Solana",network:"solana-mainnet",nativeCurrency:{name:"Solana",symbol:"SOL",decimals:9},rpcUrls:{default:{http:["https://rpc.walletconnect.org/v1"]}},blockExplorers:{default:{name:"Solscan",url:"https://solscan.io"}},testnet:!1,chainNamespace:"solana",caipNetworkId:"solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp",deprecatedCaipNetworkId:"solana:4sGjMW1sUnHzSxGspuhpqLDx6wiyjNtZ"}),r({id:"EtWTRABZaYq6iMfeYKouRu166VU2xqa1",name:"Solana Devnet",network:"solana-devnet",nativeCurrency:{name:"Solana",symbol:"SOL",decimals:9},rpcUrls:{default:{http:["https://rpc.walletconnect.org/v1"]}},blockExplorers:{default:{name:"Solscan",url:"https://solscan.io"}},testnet:!0,chainNamespace:"solana",caipNetworkId:"solana:EtWTRABZaYq6iMfeYKouRu166VU2xqa1",deprecatedCaipNetworkId:"solana:8E9rvCKLFQia2Y35HXjjpWzj8weVo44K"}),r({id:"4uhcVJyU9pJkvQyS88uRDiswHXSCkY3z",name:"Solana Testnet",network:"solana-testnet",nativeCurrency:{name:"Solana",symbol:"SOL",decimals:9},rpcUrls:{default:{http:["https://rpc.walletconnect.org/v1"]}},blockExplorers:{default:{name:"Solscan",url:"https://solscan.io"}},testnet:!0,chainNamespace:"solana",caipNetworkId:"solana:4uhcVJyU9pJkvQyS88uRDiswHXSCkY3z"}),r({id:"000000000019d6689c085ae165831e93",caipNetworkId:"bip122:000000000019d6689c085ae165831e93",chainNamespace:"bip122",name:"Bitcoin",nativeCurrency:{name:"Bitcoin",symbol:"BTC",decimals:8},rpcUrls:{default:{http:["https://rpc.walletconnect.org/v1"]}}}),r({id:"000000000933ea01ad0ee984209779ba",caipNetworkId:"bip122:000000000933ea01ad0ee984209779ba",chainNamespace:"bip122",name:"Bitcoin Testnet",nativeCurrency:{name:"Bitcoin",symbol:"BTC",decimals:8},rpcUrls:{default:{http:["https://rpc.walletconnect.org/v1"]}},testnet:!0}),r({id:"00000008819873e925422c1ff0f99f7c",caipNetworkId:"bip122:00000008819873e925422c1ff0f99f7c",chainNamespace:"bip122",name:"Bitcoin Signet",nativeCurrency:{name:"Bitcoin",symbol:"BTC",decimals:8},rpcUrls:{default:{http:["https://rpc.walletconnect.org/v1"]}},testnet:!0}),r({id:"-239",name:"TON",network:"ton-mainnet",nativeCurrency:{name:"TON",symbol:"TON",decimals:9},rpcUrls:{default:{http:["https://rpc.walletconnect.org/v1"]}},blockExplorers:{default:{name:"Tonscan",url:"https://tonscan.org"}},testnet:!1,chainNamespace:"ton",caipNetworkId:"ton:-239"}),r({id:"-3",name:"TON Testnet",network:"ton-testnet",nativeCurrency:{name:"TON",symbol:"TON",decimals:9},rpcUrls:{default:{http:["https://rpc.walletconnect.org/v1"]}},blockExplorers:{default:{name:"Tonscan",url:"https://testnet.tonscan.org"}},testnet:!0,chainNamespace:"ton",caipNetworkId:"ton:-3"});var a=e.i(236983),o=e.i(321960),s=e.i(792890),c=e.i(604647),l=e.i(206148);async function d(e,t){let n;if((n="function"==typeof t.connector?e._internal.connectors.setup(t.connector):t.connector).uid===e.state.current)throw new l.ConnectorAlreadyConnectedError;try{e.setState(e=>({...e,status:"connecting"})),n.emitter.emit("message",{type:"connecting"});let{connector:i,...r}=t,a=await n.connect(r);return n.emitter.off("connect",e._internal.events.connect),n.emitter.on("change",e._internal.events.change),n.emitter.on("disconnect",e._internal.events.disconnect),await e.storage?.setItem("recentConnectorId",n.id),e.setState(e=>({...e,connections:new Map(e.connections).set(n.uid,{accounts:r.withCapabilities?a.accounts.map(e=>"object"==typeof e?e.address:e):a.accounts,chainId:a.chainId,connector:n}),current:n.uid,status:"connected"})),{accounts:r.withCapabilities?a.accounts.map(e=>"object"==typeof e?e:{address:e,capabilities:{}}):a.accounts,chainId:a.chainId}}catch(t){throw e.setState(e=>({...e,status:e.current?"connected":"disconnected"})),t}}var h=e.i(363625);let u=e=>t=>{try{let n=e(t);if(n instanceof Promise)return n;return{then:e=>u(e)(n),catch(e){return this}}}catch(e){return{then(e){return this},catch:t=>u(t)(e)}}},g=e=>{let t,n=new Set,i=(e,i)=>{let r="function"==typeof e?e(t):e;if(!Object.is(r,t)){let e=t;t=(null!=i?i:"object"!=typeof r||null===r)?r:Object.assign({},t,r),n.forEach(n=>n(t,e))}},r=()=>t,a={setState:i,getState:r,getInitialState:()=>o,subscribe:e=>(n.add(e),()=>n.delete(e))},o=t=e(i,r,a);return a},m=e=>e?g(e):g;var C=e.i(794702);e.i(595932);var p=e.i(87246);class f{constructor(e){Object.defineProperty(this,"uid",{enumerable:!0,configurable:!0,writable:!0,value:e}),Object.defineProperty(this,"_emitter",{enumerable:!0,configurable:!0,writable:!0,value:new p.EventEmitter})}on(e,t){this._emitter.on(e,t)}once(e,t){this._emitter.once(e,t)}off(e,t){this._emitter.off(e,t)}emit(e,...t){let n=t[0];this._emitter.emit(e,{uid:this.uid,...n})}listenerCount(e){return this._emitter.listenerCount(e)}}function w(e,t){return JSON.parse(e,(e,n)=>{let i=n;return i?.__type==="bigint"&&(i=BigInt(i.value)),i?.__type==="Map"&&(i=new Map(i.value)),t?.(e,i)??i})}function v(e,t){return e.slice(0,t).join(".")||"."}function I(e,t){let{length:n}=e;for(let i=0;i<n;++i)if(e[i]===t)return i+1;return 0}function y(e,t,n,i){var r;let a,o,s,c;return JSON.stringify(e,(r=(e,n)=>{let i=n;return"bigint"==typeof i&&(i={__type:"bigint",value:n.toString()}),i instanceof Map&&(i={__type:"Map",value:Array.from(n.entries())}),t?.(e,i)??i},a=true,o="function"==typeof i,s=[],c=[],function(e,t){if("object"==typeof t)if(s.length){let n=I(s,this);0===n?s[s.length]=this:(s.splice(n),c.splice(n)),c[c.length]=e;let r=I(s,t);if(0!==r)return o?i.call(this,e,t,v(c,r)):`[ref=${v(c,r)}]`}else s[0]=t,c[0]=e;return a?r.call(this,e,t):t}),n??void 0)}let b={getItem:()=>null,setItem:()=>{},removeItem:()=>{}},N=256;var E=e.i(296247),A=e.i(123555),A=A,U=e.i(153077);function S(e,t,n){let i=e[t.name];if("function"==typeof i)return i;let r=e[n];return"function"==typeof r?r:n=>t(e,n)}async function P(e,t){let{address:n,blockNumber:i,blockTag:r,chainId:a}=t,o=e.getClient({chainId:a}),s=S(o,U.getBalance,"getBalance"),c=await s(i?{address:n,blockNumber:i}:{address:n,blockTag:r}),l=e.chains.find(e=>e.id===a)??o.chain;return{decimals:l.nativeCurrency.decimals,symbol:l.nativeCurrency.symbol,value:c}}var T=e.i(324307),k=e.i(368941),R=A;async function _(e,t){let{account:n,chainId:i,...r}=t,a=n??(0,R.getConnection)(e).address;return S(e.getClient({chainId:i}),k.prepareTransactionRequest,"prepareTransactionRequest")({...r,...a?{account:a}:{}})}var O=e.i(337917),W=e.i(599976),M=e.i(911347),j=e.i(823838),D=e.i(189991);async function H(e,t={}){let n,{assertChainId:i=!0}=t;if(t.connector){let{connector:i}=t;if("reconnecting"===e.state.status&&!i.getAccounts&&!i.getChainId)throw new l.ConnectorUnavailableReconnectingError({connector:i});let[r,a]=await Promise.all([i.getAccounts().catch(e=>{if(null===t.account)return[];throw e}),i.getChainId()]);n={accounts:r,chainId:a,connector:i}}else n=e.state.connections.get(e.state.current);if(!n)throw new l.ConnectorNotConnectedError;let r=t.chainId??n.chainId,a=await n.connector.getChainId();if(i&&a!==r)throw new l.ConnectorChainMismatchError({connectionChainId:r,connectorChainId:a});let o=n.connector;if(o.getClient)return o.getClient({chainId:r});let s=(0,D.parseAccount)(t.account??n.accounts[0]);if(s&&(s.address=(0,j.getAddress)(s.address)),t.account&&!n.accounts.some(e=>e.toLowerCase()===s.address.toLowerCase()))throw new l.ConnectorAccountNotFoundError({address:s.address,connector:o});let c=e.chains.find(e=>e.id===r),d=await n.connector.getProvider({chainId:r});return(0,h.createClient)({account:s,chain:c,name:"Connector Client",transport:e=>(0,M.custom)(d)({...e,retryCount:0})})}async function q(e,t){let{account:n,connector:i,...r}=t;return S("object"==typeof n&&"local"===n.type?e.getClient():await H(e,{account:n,connector:i}),W.signMessage,"signMessage")({...r,...n?{account:n}:{}})}var L=e.i(377349);async function x(e,t){let{addEthereumChainParameter:n,chainId:i}=t,r=e.state.connections.get(t.connector?.uid??e.state.current);if(r){let e=r.connector;if(!e.switchChain)throw new L.SwitchChainNotSupportedError({connector:e});return await e.switchChain({addEthereumChainParameter:n,chainId:i})}let a=e.chains.find(e=>e.id===i);if(!a)throw new l.ChainNotConfiguredError;return e.setState(e=>({...e,chainId:i})),a}var F=e.i(6110),B=e.i(484734);async function V(e,t){let n,{chainId:i,connector:r,...a}=t;return n=t.account?t.account:(await H(e,{account:t.account,assertChainId:!1,chainId:i,connector:r})).account,S(e.getClient({chainId:i}),B.estimateGas,"estimateGas")({...a,account:n})}var z=e.i(888794);async function K(e,t){let n,{account:i,chainId:r,connector:a,...o}=t;n="object"==typeof i&&i?.type==="local"?e.getClient({chainId:r}):await H(e,{account:i??void 0,assertChainId:!1,chainId:r,connector:a});let s=r&&n.chain?.id!==r?{id:r}:n.chain,c=S(n,z.sendTransaction,"sendTransaction");return await c({...o,...i?{account:i}:{},assertChainId:!!r,chain:s,gas:o.gas??void 0})}var G=e.i(938630);async function J(e,t){let n,{account:i,chainId:r,connector:a,...o}=t;n="object"==typeof i&&i?.type==="local"?e.getClient({chainId:r}):await H(e,{account:i??void 0,assertChainId:!1,chainId:r,connector:a});let s=r&&n.chain?.id!==r?{id:r}:n.chain,c=S(n,G.writeContract,"writeContract");return await c({...o,...i?{account:i}:{},assertChainId:!!r,chain:s})}var $=e.i(450323),Y=e.i(989509),X=e.i(579917),Q=e.i(948789);async function Z(e,t){let{chainId:n,timeout:i=0,...r}=t,a=e.getClient({chainId:n}),o=S(a,Q.waitForTransactionReceipt,"waitForTransactionReceipt"),s=await o({...r,timeout:i});if("reverted"===s.status){let e=S(a,X.getTransaction,"getTransaction"),{from:t,...n}=await e({hash:s.transactionHash}),i=S(a,Y.call,"call"),r=await i({...n,account:t,data:n.input,gasPrice:"eip1559"!==n.type?n.gasPrice:void 0,maxFeePerGas:"eip1559"===n.type?n.maxFeePerGas:void 0,maxPriorityFeePerGas:"eip1559"===n.type?n.maxPriorityFeePerGas:void 0});throw Error(r?.data?(0,$.hexToString)(`0x${r.data.substring(138)}`):"unknown reason")}return{...s,chainId:a.chain.id}}var ee=e.i(225580),ee=ee,et=e.i(331587),en=e.i(395024),ei=e.i(383856),er=e.i(644616),ea=e.i(668375),eo=e.i(683075),es=e.i(401564),ec=e.i(681285),el=e.i(56774),ed=e.i(637824),eh=e.i(241845),eu=e.i(960398),eg=e.i(227302),em=e.i(82283),eC=e.i(758331),ep=e.i(757758),ef=e.i(334523),ew=e.i(769718),ev=e.i(689862),eI=e.i(851887),ey=e.i(149454),eb=e.i(218454),eN=e.i(564126),eE=e.i(535568),eA=e.i(292227);e.i(971342);var eU=e.i(675107),eS=e.i(354157);function eP(e){let t,n,i,r,a,o,s,c=e.isNewChainsStale??!0;return(0,ev.createConnector)(d=>({id:"walletConnect",name:"WalletConnect",type:eP.type,provider:e.universalProvider,async setup(){let e=await this.getProvider().catch(()=>null);e&&(r||(r=this.onConnect.bind(this),e.on("connect",r)),o||(o=this.onSessionDelete.bind(this),e.on("session_delete",o)))},async connect({...e}={}){try{let t=eu.ChainController.getCaipNetworks(),c=await this.getProvider();if(!c)throw new L.ProviderNotFoundError;a||(a=this.onDisplayUri,c.on("display_uri",a));let l=await this.isChainsStale();c.session&&l&&await c.disconnect();let d=em.OptionsController.state.universalProviderConfigOverride;if(!c.session||l){let n=eS.WcHelpersUtil.createNamespaces(t,d);await c.connect({optionalNamespaces:n,..."pairingTopic"in e?{pairingTopic:e.pairingTopic}:{}}),this.setRequestedChainsIds(t.map(e=>Number(e.id)))}let h=await this.getAccounts(),u=await this.getChainId(),g=c.session?.namespaces?.eip155?.chains,m=g?.some(e=>Number(e.split(":")[1])===u),C=1;m?C=u:g?.[0]&&(C=Number(g[0].split(":")[1])),a&&(c.removeListener("display_uri",a),a=void 0),r&&(c.removeListener("connect",r),r=void 0),n||(n=this.onAccountsChanged.bind(this),c.on("accountsChanged",n)),i||(i=this.onChainChanged.bind(this),c.on("chainChanged",i)),s||(s=this.onDisconnect.bind(this),c.on("disconnect",s)),o||(o=this.onSessionDelete.bind(this),c.on("session_delete",o));let p=d?.defaultChain;return c.setDefaultChain(p??`eip155:${C}`),{accounts:h,chainId:C}}catch(e){if(/(user rejected|connection request reset)/i.test(e?.message))throw new ei.UserRejectedRequestError(e);throw e}},async disconnect(){let e=await this.getProvider();try{await e?.disconnect()}catch(e){if(!/No matching key/i.test(e.message))throw e}finally{i&&(e?.removeListener("chainChanged",i),i=void 0),s&&(e?.removeListener("disconnect",s),s=void 0),r||(r=this.onConnect.bind(this),e?.on("connect",r)),n&&(e?.removeListener("accountsChanged",n),n=void 0),o&&(e?.removeListener("session_delete",o),o=void 0),this.setRequestedChainsIds([])}},async getAccounts(){let e=await this.getProvider();if(!e?.session?.namespaces)return[];let t=e?.session?.namespaces[es.ConstantsUtil.CHAIN.EVM]?.accounts,n=t?.map(e=>e.split(":")[2])??[],i=new Set;return n.filter(e=>{let t=e?.toLowerCase();return!i.has(t)&&(i.add(t),!0)})},async getProvider({chainId:n}={}){t||(t=e.universalProvider,t?.events.setMaxListeners(1/0));let i=eC.StorageUtil.getActiveNamespace(),r=eu.ChainController.getActiveCaipNetwork()?.id;if(n&&r!==n&&i){let e=eC.StorageUtil.getStoredActiveCaipNetworkId(),t=i?eu.ChainController.getCaipNetworks(i):[],n=t?.find(t=>t.id===e);n&&n.chainNamespace===es.ConstantsUtil.CHAIN.EVM&&await this.switchChain?.({chainId:Number(n.id)})}return t},async getChainId(){let e=eu.ChainController.getActiveCaipNetwork(es.ConstantsUtil.CHAIN.EVM)?.id;if(e)return e;let t=await this.getProvider(),n=t.session?.namespaces[es.ConstantsUtil.CHAIN.EVM]?.chains?.[0],i=eu.ChainController.getCaipNetworks().find(e=>e.id===n);return i?.id},async isAuthorized(){try{let[e,t]=await Promise.all([this.getAccounts(),this.getProvider()]);if(!e.length)return!1;if(await this.isChainsStale()&&t.session)return await t.disconnect().catch(()=>{}),!1;return!0}catch{return!1}},async switchChain({addEthereumChainParameter:e,chainId:t}){let n=await this.getProvider();if(!n)throw new L.ProviderNotFoundError;let i=eu.ChainController.getCaipNetworks().find(e=>e.id===t);if(!i)throw new ei.SwitchChainError(new l.ChainNotConfiguredError);try{await n.request({method:"wallet_switchEthereumChain",params:[{chainId:(0,eU.numberToHex)(t)}]}),i?.caipNetworkId&&n.setDefaultChain(i?.caipNetworkId),d.emitter.emit("change",{chainId:Number(t)});let e=await this.getRequestedChainsIds();return this.setRequestedChainsIds([...e,t]),{...i,id:i.id}}catch(r){if(/(?:user rejected)/iu.test(r.message))throw new ei.UserRejectedRequestError(r);try{let r;r=e?.blockExplorerUrls?e.blockExplorerUrls:i.blockExplorers?.default.url?[i.blockExplorers?.default.url]:[];let a=i.rpcUrls?.chainDefault?.http||[],o={blockExplorerUrls:r,chainId:(0,eU.numberToHex)(t),chainName:i.name,iconUrls:e?.iconUrls,nativeCurrency:i.nativeCurrency,rpcUrls:a};await n.request({method:"wallet_addEthereumChain",params:[o]});let s=await this.getRequestedChainsIds();return this.setRequestedChainsIds([...s,t]),{...i,id:i.id}}catch(e){throw new ei.UserRejectedRequestError(e)}}},onAccountsChanged(e){0===e.length?this.onDisconnect():d.emitter.emit("change",{accounts:e.map(e=>(0,j.getAddress)(e))})},onChainChanged(e){let t=Number(e);d.emitter.emit("change",{chainId:t})},onConnect(e){this.setRequestedChainsIds(eu.ChainController.getCaipNetworks().map(e=>Number(e.id)))},async onDisconnect(e){this.setRequestedChainsIds([]),d.emitter.emit("disconnect");let t=await this.getProvider();n&&(t.removeListener("accountsChanged",n),n=void 0),i&&(t.removeListener("chainChanged",i),i=void 0),s&&(t.removeListener("disconnect",s),s=void 0),o&&(t.removeListener("session_delete",o),o=void 0),r||(r=this.onConnect.bind(this),t.on("connect",r))},onDisplayUri(e){d.emitter.emit("message",{type:"display_uri",data:e})},onSessionDelete(){this.onDisconnect()},getNamespaceChainsIds(){if(!t?.session?.namespaces)return[];let e=t?.session?.namespaces[es.ConstantsUtil.CHAIN.EVM]?.accounts;return e?.map(e=>Number.parseInt(e.split(":")[1]??""))??[]},async getRequestedChainsIds(){return[...new Set(await d.storage?.getItem(this.requestedChainsStorageKey)??[])]},async isChainsStale(){if(!c)return!1;let e=d.chains.map(e=>e.id),t=this.getNamespaceChainsIds();if(t.length&&!t.some(t=>e.includes(t)))return!1;let n=await this.getRequestedChainsIds();return!e.every(e=>n.includes(Number(e)))},async setRequestedChainsIds(e){await d.storage?.setItem(this.requestedChainsStorageKey,e)},get requestedChainsStorageKey(){return`${this.id}.requestedChains`}}))}eP.type="walletConnect";var eT=e.i(365801),ek=e.i(742710);let eR=(0,eT.proxy)({pendingTransactions:0}),e_={state:eR,subscribeKey:(e,t)=>(0,ek.subscribeKey)(eR,e,t),increase(e){eR[e]+=1},decrease(e){eR[e]-=1},reset(e){eR[e]=0}};async function eO(t){if(eg.CoreHelperUtil.isSafeApp()){let{safe:n}=await e.A(149428);if(n&&!t.some(e=>"safe"===e.type))return n()}return null}async function eW(t){try{let{baseAccount:n}=await e.A(149428);if(n&&!t.some(e=>"baseAccount"===e.id))return n()}catch(e){console.error("Failed to import Coinbase Wallet SDK:",e)}return null}let eM={enable:!1,pollingInterval:3e4};class ej extends ed.AdapterBlueprint{constructor(e){const t=ef.CaipNetworksUtil.extendCaipNetworks(e.networks,{projectId:e.projectId,customNetworkImageUrls:{},customRpcUrls:e.customRpcUrls});super(),this.balancePromises={},this.namespace=es.ConstantsUtil.CHAIN.EVM,this.adapterType=es.ConstantsUtil.ADAPTER_TYPES.WAGMI,this.projectId=e.projectId,this.pendingTransactionsFilter={...eM,...e.pendingTransactionsFilter??{}},this.createConfig({...e,networks:t}),this.checkChainId()}construct(e){this.checkChainId(),this.setupWatchers()}async getAccounts(e){let t=this.getWagmiConnector(e.id);if(!t)return{accounts:[]};if(t.id===es.ConstantsUtil.CONNECTOR_ID.AUTH){let e=await t.getProvider();if(!e?.user)return{accounts:[]};let{address:n,accounts:i}=e.user;return Promise.resolve({accounts:(i||[{address:n,type:"eoa"}]).map(e=>eg.CoreHelperUtil.createAccount("eip155",e.address,e.type))})}let{addresses:n,address:i}=(0,A.getConnection)(this.wagmiConfig);return Promise.resolve({accounts:[...new Set(n||[i])].map(e=>eg.CoreHelperUtil.createAccount("eip155",e||"","eoa"))})}checkChainId(){let{chainId:e}=(0,A.getConnection)(this.wagmiConfig);e&&this.emit("switchNetwork",{chainId:e})}getWagmiConnector(e){return this.wagmiConfig.connectors.find(t=>t.id===e)}createConfig(e){this.wagmiChains=e.networks.filter(e=>e.chainNamespace===es.ConstantsUtil.CHAIN.EVM);let n={},i=[...e.connectors??[]];this.wagmiChains.forEach(t=>{let i=e.transports?.[t.id],r=ef.CaipNetworksUtil.getCaipNetworkId(t);i?n[t.id]=ef.CaipNetworksUtil.extendWagmiTransports(t,e.projectId,i):n[t.id]=ef.CaipNetworksUtil.getViemTransport(t,e.projectId,e.customRpcUrls?.[r])}),this.wagmiConfig=function(e){let n,i,r,a,o,s,c,d,{multiInjectedProviderDiscovery:g=!0,storage:p=function(e){let{deserialize:t=w,key:n="wagmi",serialize:i=y,storage:r=b}=e;function a(e){return e instanceof Promise?e.then(e=>e).catch(()=>null):e}return{...r,key:n,async getItem(e,i){let o=r.getItem(`${n}.${e}`),s=await a(o);return s?t(s)??null:i??null},async setItem(e,t){let o=`${n}.${e}`;null===t?await a(r.removeItem(o)):await a(r.setItem(o,i(t)))},async removeItem(e){await a(r.removeItem(`${n}.${e}`))}}}({storage:(i="u">typeof window&&window.localStorage?window.localStorage:b,{getItem:e=>i.getItem(e),removeItem(e){i.removeItem(e)},setItem(e,t){try{i.setItem(e,t)}catch{}}})}),syncConnectedChain:v=!0,ssr:I=!1,...A}=e,U="u">typeof window&&g?(r=new Set,a=[],s=(o=()=>(function(e){if("u"<typeof window)return;let t=t=>e(t.detail);return window.addEventListener("eip6963:announceProvider",t),window.dispatchEvent(new CustomEvent("eip6963:requestProvider")),()=>window.removeEventListener("eip6963:announceProvider",t)})(e=>{a.some(({info:t})=>t.uuid===e.info.uuid)||(a=[...a,e],r.forEach(t=>t(a,{added:[e]})))}))(),{_listeners:()=>r,clear(){r.forEach(e=>e([],{removed:[...a]})),a=[]},destroy(){this.clear(),r.clear(),s?.()},findProvider:({rdns:e})=>a.find(t=>t.info.rdns===e),getProviders:()=>a,reset(){this.clear(),s?.(),s=o()},subscribe:(e,{emitImmediately:t}={})=>(r.add(e),t&&e(a,{added:a}),()=>r.delete(e))}):void 0,S=m(()=>A.chains),P=m(()=>{let e=[],t=new Set;for(let n of A.connectors??[]){let i=T(n);if(e.push(i),!I&&i.rdns)for(let e of"string"==typeof i.rdns?[i.rdns]:i.rdns)t.add(e)}if(!I&&U)for(let n of U.getProviders())t.has(n.info.rdns)||e.push(T(k(n)));return e});function T(e){let n=new f(function(e=11){if(!t||N+e>512){t="",N=0;for(let e=0;e<256;e++)t+=(256+256*Math.random()|0).toString(16).substring(1)}return t.substring(N,N+++e)}()),i={...e({emitter:n,chains:S.getState(),storage:p,transports:A.transports}),emitter:n,uid:n.uid};return n.on("connect",D),i.setup?.(),i}function k(e){let{info:t}=e,n=e.provider;return(0,C.injected)({target:{...t,id:t.rdns,provider:n}})}let R=new Map;function _(){return{chainId:S.getState()[0].id,connections:new Map,current:null,status:"disconnected"}}let O="0.0.0-canary-";n=E.version.startsWith(O)?Number.parseInt(E.version.replace(O,""),10):Number.parseInt(E.version.split(".")[0]??"0",10);let W=m((d=p?(c={migrate(e,t){if(t===n)return e;let i=_(),r=M(e,i.chainId);return{...i,chainId:r}},name:"store",partialize:e=>({connections:{__type:"Map",value:Array.from(e.connections.entries()).map(([e,t])=>{let{id:n,name:i,type:r,uid:a}=t.connector;return[e,{...t,connector:{id:n,name:i,type:r,uid:a}}]})},chainId:e.chainId,current:e.current}),merge(e,t){"object"==typeof e&&e&&"status"in e&&delete e.status;let n=M(e,t.chainId);return{...t,...e,chainId:n}},skipHydration:I,storage:p,version:n},(e,t,n)=>{let i,r={storage:function(e,t){let n;try{n=e()}catch(e){return}return{getItem:e=>{var t;let i=e=>null===e?null:JSON.parse(e,void 0),r=null!=(t=n.getItem(e))?t:null;return r instanceof Promise?r.then(i):i(r)},setItem:(e,t)=>n.setItem(e,JSON.stringify(t,void 0)),removeItem:e=>n.removeItem(e)}}(()=>localStorage),partialize:e=>e,version:0,merge:(e,t)=>({...t,...e}),...c},a=!1,o=new Set,s=new Set,l=r.storage;if(!l)return _((...t)=>{console.warn(`[zustand persist middleware] Unable to update item '${r.name}', the given storage is currently unavailable.`),e(...t)},t,n);let d=()=>{let e=r.partialize({...t()});return l.setItem(r.name,{state:e,version:r.version})},h=n.setState;n.setState=(e,t)=>{h(e,t),d()};let g=_((...t)=>{e(...t),d()},t,n);n.getInitialState=()=>g;let m=()=>{var n,c;if(!l)return;a=!1,o.forEach(e=>{var n;return e(null!=(n=t())?n:g)});let h=(null==(c=r.onRehydrateStorage)?void 0:c.call(r,null!=(n=t())?n:g))||void 0;return u(l.getItem.bind(l))(r.name).then(e=>{if(e)if("number"!=typeof e.version||e.version===r.version)return[!1,e.state];else{if(r.migrate)return[!0,r.migrate(e.state,e.version)];console.error("State loaded from storage couldn't be migrated since no migrate function was provided")}return[!1,void 0]}).then(n=>{var a;let[o,s]=n;if(e(i=r.merge(s,null!=(a=t())?a:g),!0),o)return d()}).then(()=>{null==h||h(i,void 0),i=t(),a=!0,s.forEach(e=>e(i))}).catch(e=>{null==h||h(void 0,e)})};return n.persist={setOptions:e=>{r={...r,...e},e.storage&&(l=e.storage)},clearStorage:()=>{null==l||l.removeItem(r.name)},getOptions:()=>r,rehydrate:()=>m(),hasHydrated:()=>a,onHydrate:e=>(o.add(e),()=>{o.delete(e)}),onFinishHydration:e=>(s.add(e),()=>{s.delete(e)})},r.skipHydration||m(),i||g}):_,(e,t,n)=>{let i=n.subscribe;return n.subscribe=(e,t,r)=>{let a=e;if(t){let i=(null==r?void 0:r.equalityFn)||Object.is,o=e(n.getState());a=n=>{let r=e(n);if(!i(o,r)){let e=o;t(o=r,e)}},(null==r?void 0:r.fireImmediately)&&t(o,o)}return i(a)},d(e,t,n)}));function M(e,t){return e&&"object"==typeof e&&"chainId"in e&&"number"==typeof e.chainId&&S.getState().some(t=>t.id===e.chainId)?e.chainId:t}function j(e){W.setState(t=>{let n=t.connections.get(e.uid);return n?{...t,connections:new Map(t.connections).set(e.uid,{accounts:e.accounts??n.accounts,chainId:e.chainId??n.chainId,connector:n.connector})}:t})}function D(e){"connecting"!==W.getState().status&&"reconnecting"!==W.getState().status&&W.setState(t=>{let n=P.getState().find(t=>t.uid===e.uid);return n?(n.emitter.listenerCount("connect")&&n.emitter.off("connect",j),n.emitter.listenerCount("change")||n.emitter.on("change",j),n.emitter.listenerCount("disconnect")||n.emitter.on("disconnect",H),{...t,connections:new Map(t.connections).set(e.uid,{accounts:e.accounts,chainId:e.chainId,connector:n}),current:e.uid,status:"connected"}):t})}function H(e){W.setState(t=>{let n=t.connections.get(e.uid);if(n){let e=n.connector;e.emitter.listenerCount("change")&&n.connector.emitter.off("change",j),e.emitter.listenerCount("disconnect")&&n.connector.emitter.off("disconnect",H),e.emitter.listenerCount("connect")||n.connector.emitter.on("connect",D)}if(t.connections.delete(e.uid),0===t.connections.size)return{...t,connections:new Map,current:null,status:"disconnected"};let i=t.connections.values().next().value;return{...t,connections:new Map(t.connections),current:i.connector.uid}})}return W.setState(_()),v&&W.subscribe(({connections:e,current:t})=>t?e.get(t)?.chainId:void 0,e=>{if(S.getState().some(t=>t.id===e))return W.setState(t=>({...t,chainId:e??t.chainId}))}),U?.subscribe(e=>{let t=new Set,n=new Set;for(let e of P.getState())if(t.add(e.id),e.rdns)for(let t of"string"==typeof e.rdns?[e.rdns]:e.rdns)n.add(t);let i=[];for(let r of e){if(n.has(r.info.rdns))continue;let e=T(k(r));t.has(e.id)||i.push(e)}(!p||W.persist.hasHydrated())&&P.setState(e=>[...e,...i],!0)}),{get chains(){return S.getState()},get connectors(){return P.getState()},storage:p,getClient:function(e={}){let t,n=e.chainId??W.getState().chainId,i=S.getState().find(e=>e.id===n);if(e.chainId&&!i)throw new l.ChainNotConfiguredError;{let e=R.get(W.getState().chainId);if(e&&!i)return e;if(!i)throw new l.ChainNotConfiguredError}{let e=R.get(n);if(e)return e}if(A.client)t=A.client({chain:i});else{let e=i.id,n=S.getState().map(e=>e.id),r={};for(let[t,i]of Object.entries(A))if("chains"!==t&&"client"!==t&&"connectors"!==t&&"transports"!==t)if("object"==typeof i)if(e in i)r[t]=i[e];else{if(n.some(e=>e in i))continue;r[t]=i}else r[t]=i;t=(0,h.createClient)({...r,chain:i,batch:r.batch??{multicall:!0},transport:t=>A.transports[e]({...t,connectors:P})})}return R.set(n,t),t},get state(){return W.getState()},setState(e){let t;t="function"==typeof e?e(W.getState()):e;let n=_();"object"!=typeof t&&(t=n),Object.keys(n).some(e=>!(e in t))&&(t=n),W.setState(t,!0)},subscribe:(e,t,n)=>W.subscribe(e,t,n?{...n,fireImmediately:n.emitImmediately}:void 0),_internal:{mipd:U,async revalidate(){let e=W.getState(),t=e.connections,n=e.current;for(let[,e]of t){let i=e.connector;i.isAuthorized&&await i.isAuthorized()||(t.delete(i.uid),n===i.uid&&(n=null))}W.setState(e=>({...e,connections:t,current:n}))},store:W,ssr:!!I,syncConnectedChain:v,transports:A.transports,chains:{setState(e){let t="function"==typeof e?e(S.getState()):e;if(0!==t.length)return S.setState(t,!0)},subscribe:e=>S.subscribe(e)},connectors:{providerDetailToConnector:k,setup:T,setState:e=>P.setState("function"==typeof e?e(P.getState()):e,!0),subscribe:e=>P.subscribe(e)},events:{change:j,connect:D,disconnect:H}}}}({...e,chains:this.wagmiChains,connectors:i,transports:n})}setupWatchPendingTransactions(){if(!this.pendingTransactionsFilter.enable||this.unwatchPendingTransactions)return;this.unwatchPendingTransactions=function(e,t){let n,i,{syncConnectedChain:r=e._internal.syncConnectedChain,...a}=t,o=t=>(n&&n(),n=S(e.getClient({chainId:t}),en.watchPendingTransactions,"watchPendingTransactions")(a)),s=o(t.chainId);return r&&!t.chainId&&(i=e.subscribe(({chainId:e})=>e,async e=>o(e))),()=>{s?.(),i?.()}}(this.wagmiConfig,{pollingInterval:this.pendingTransactionsFilter.pollingInterval,onError:()=>{},onTransactions:()=>{this.emit("pendingTransactions"),e_.increase("pendingTransactions")}});let e=e_.subscribeKey("pendingTransactions",t=>{t>=es.ConstantsUtil.LIMITS.PENDING_TRANSACTIONS&&(this.unwatchPendingTransactions?.(),e())})}setupWatchers(){(0,et.watchConnections)(this.wagmiConfig,{onChange:e=>{this.clearConnections(),this.addConnection(...e.map(e=>{let t=this.getCaipNetworks().find(t=>t.id===e.chainId),n=e.connector.id===es.ConstantsUtil.CONNECTOR_ID.AUTH;return{accounts:e.accounts.map(e=>({address:this.toChecksummedAddress(e)})),caipNetwork:t,connectorId:e.connector.id,auth:n?{name:eC.StorageUtil.getConnectedSocialProvider(),username:eC.StorageUtil.getConnectedSocialUsername()}:void 0}}))}}),(0,ee.watchConnection)(this.wagmiConfig,{onChange:(e,t)=>{if("disconnected"===e.status&&t.address&&this.emit("disconnect"),e?.chainId&&e?.chainId!==t?.chainId&&this.emit("switchNetwork",{chainId:e.chainId}),"connected"===e.status){let n=e.address!==t?.address,i=e.connector.id!==t.connector?.id,r="connected"!==t.status;(n||i||r)&&(this.setupWatchPendingTransactions(),this.handleAccountChanged({address:e.address,chainId:e.chainId,connector:e.connector}))}}})}async addThirdPartyConnectors(){let e=[],{enableCoinbase:t}=em.OptionsController.state||{};if(!1!==t){let t=await eW(this.wagmiConfig.connectors);t&&e.push(t)}let n=await eO(this.wagmiConfig.connectors);n&&e.push(n),await Promise.all(e.map(e=>{let t=this.configureInternalConnector(e);return this.addWagmiConnector(t)}))}addWagmiConnectors(){let e=[];!1!==em.OptionsController.state.enableInjected&&e.push((0,C.injected)({shimDisconnect:!0}));let{features:t,remoteFeatures:n,projectId:i,enableAuthLogger:r}=em.OptionsController.state,a=n?.email??t?.email??!0,o=n?.socials??t?.socials,s=Array.isArray(o)&&o?.length>0;(a||s)&&e.push(function(e){let t,n,i=[];function r(e){let t=eu.ChainController.getCaipNetworks(es.ConstantsUtil.CHAIN.EVM),n=Number(ec.NetworkUtil.parseEvmChainId(e));if(!t.some(t=>String(t.id)===String(e))){let e=eu.ChainController.getActiveCaipNetwork(es.ConstantsUtil.CHAIN.EVM)?.id||t[0]?.id;e&&Number.isInteger(Number(e))&&(n=Number(e))}if(!n)throw Error("ChainId not found in networks");return n}async function a(n={}){let o=(t||(t=eA.W3mFrameProviderSingleton.getInstance({projectId:e.options.projectId,chainId:(0,eN.getActiveCaipNetwork)()?.caipNetworkId,enableLogger:e.options.enableAuthLogger,onTimeout:e=>{"iframe_load_failed"===e?eI.AlertController.open(eE.ErrorUtil.ALERT_ERRORS.IFRAME_LOAD_FAILED,"error"):"iframe_request_timeout"===e?eI.AlertController.open(eE.ErrorUtil.ALERT_ERRORS.IFRAME_REQUEST_TIMEOUT,"error"):"unverified_domain"===e&&eI.AlertController.open(eE.ErrorUtil.ALERT_ERRORS.UNVERIFIED_DOMAIN,"error")},abortController:eE.ErrorUtil.EmbeddedWalletAbortController,getActiveCaipNetwork:e=>(0,eN.getActiveCaipNetwork)(e),getCaipNetworks:e=>eu.ChainController.getCaipNetworks(e)})),t),s=n.chainId;if(n.isReconnecting){let t=ec.NetworkUtil.parseEvmChainId(o.getLastUsedChainId()||""),n=e.chains?.[0].id;if(!(s=t||n))throw Error("ChainId not found in provider")}let c=(0,eN.getPreferredAccountType)("eip155"),{address:l,chainId:d,accounts:h}=await eb.SIWXUtil.authConnectorAuthenticate({authConnector:o,chainId:s,preferredAccountType:c,socialUri:n.socialUri,chainNamespace:es.ConstantsUtil.CHAIN.EVM});i=h?.map(e=>e.address)||[l];let u=r(d);return{accounts:i,account:l,chainId:u,chain:{id:u,unsupported:!1}}}return(0,ev.createConnector)(t=>({id:es.ConstantsUtil.CONNECTOR_ID.AUTH,name:es.ConstantsUtil.CONNECTOR_NAMES.AUTH,type:"AUTH",chain:es.ConstantsUtil.CHAIN.EVM,async connect(e={}){if(n){let t=await n;return{accounts:e.withCapabilities?t.accounts.map(e=>({address:e,capabilities:{}})):t.accounts,chainId:t.chainId}}n||(n=new Promise(t=>{t(a(e))}));let t=await n;return n=void 0,{accounts:e.withCapabilities?t.accounts.map(e=>({address:e,capabilities:{}})):t.accounts,chainId:t.chainId}},async disconnect(){let e=await this.getProvider();await e.disconnect()},getAccounts:()=>i?.length?(t.emitter.emit("change",{accounts:i}),Promise.resolve(i)):Promise.resolve([]),async getProvider(){return this.provider||(this.provider=eA.W3mFrameProviderSingleton.getInstance({projectId:e.options.projectId,chainId:(0,eN.getActiveCaipNetwork)()?.caipNetworkId,enableLogger:e.options.enableAuthLogger,abortController:eE.ErrorUtil.EmbeddedWalletAbortController,onTimeout:e=>{"iframe_load_failed"===e?eI.AlertController.open(eE.ErrorUtil.ALERT_ERRORS.IFRAME_LOAD_FAILED,"error"):"iframe_request_timeout"===e?eI.AlertController.open(eE.ErrorUtil.ALERT_ERRORS.IFRAME_REQUEST_TIMEOUT,"error"):"unverified_domain"===e&&eI.AlertController.open(eE.ErrorUtil.ALERT_ERRORS.UNVERIFIED_DOMAIN,"error")},getActiveCaipNetwork:e=>(0,eN.getActiveCaipNetwork)(e),getCaipNetworks:e=>eu.ChainController.getCaipNetworks(e)})),Promise.resolve(this.provider)},async getChainId(){let e=await this.getProvider(),{chainId:t}=await e.getChainId();return r(t)},async isAuthorized(){let e=eu.ChainController.state.activeChain===es.ConstantsUtil.CHAIN.EVM;return(!es.ConstantsUtil.AUTH_CONNECTOR_SUPPORTED_CHAINS.some(e=>ey.ConnectorController.getConnectorId(e)===es.ConstantsUtil.CONNECTOR_ID.AUTH)||!!e)&&Promise.resolve((await this.getProvider()).getLoginEmailUsed())},async switchChain({chainId:e}){try{let n=t.chains.find(t=>t.id===e);if(!n)throw new ei.SwitchChainError(Error("chain not found on connector."));let r=await this.getProvider(),a=(0,eN.getPreferredAccountType)("eip155"),o=await r.connect({chainId:e,preferredAccountType:a});return i=o?.accounts?.map(e=>e.address)||[o.address],t.emitter.emit("change",{chainId:Number(e),accounts:i}),n}catch(e){if(e instanceof Error)throw new ei.SwitchChainError(e);throw e}},onAccountsChanged(e){0===e.length?this.onDisconnect():t.emitter.emit("change",{accounts:e.map(j.getAddress)})},onChainChanged(e){let n=Number(e);t.emitter.emit("change",{chainId:n})},async onDisconnect(e){let t=await this.getProvider();await t.disconnect()}}))}({chains:this.wagmiChains,options:{projectId:i,enableAuthLogger:r}})),e.forEach(e=>{this.configureInternalConnector(e)})}configureInternalConnector(e){let t=this.wagmiConfig._internal.connectors.setup(e);return this.wagmiConfig._internal.connectors.setState(e=>[...e,t]),t}async handleAccountChanged({address:e,chainId:t,connector:n}){if(!this.namespace)throw Error("WagmiAdapter:handleAccountChanged - namespace is required");let i=await n.getProvider().catch(()=>void 0);this.emit("accountChanged",{address:this.toChecksummedAddress(e),chainId:t,connector:{id:n.id,name:el.PresetsUtil.ConnectorNamesMap[n.id]??n.name,imageId:el.PresetsUtil.ConnectorImageIds[n.id],type:el.PresetsUtil.ConnectorTypesMap[n.type]??"EXTERNAL",info:n.id===es.ConstantsUtil.CONNECTOR_ID.INJECTED?void 0:{rdns:n.id},provider:i,chain:this.namespace,chains:[]}})}async writeSolanaTransaction(){return Promise.resolve({hash:""})}async signMessage(e){try{return{signature:await q(this.wagmiConfig,{message:e.message,account:e.address})}}catch(e){throw Error("WagmiAdapter:signMessage - Sign message failed")}}async sendTransaction(e){let{chainId:t,address:n}=(0,A.getConnection)(this.wagmiConfig),i=this.wagmiChains?.find(e=>e.id===t),r={account:n,to:e.to,value:Number.isNaN(Number(e.value))?BigInt(0):BigInt(e.value),gas:e.gas?BigInt(e.gas):void 0,gasPrice:e.gasPrice?BigInt(e.gasPrice):void 0,data:e.data,chain:i,type:"legacy",parameters:["nonce"]};await _(this.wagmiConfig,r);let a=await K(this.wagmiConfig,r);return await Z(this.wagmiConfig,{hash:a,timeout:25e3}),{hash:a}}async writeContract(e){let{caipNetwork:t,...n}=e,i=Number(ec.NetworkUtil.caipNetworkIdToNumber(t.caipNetworkId)),r=this.wagmiChains?.find(e=>e.id===i);return{hash:await J(this.wagmiConfig,{chain:r,address:n.tokenAddress,account:n.fromAddress,abi:n.abi,functionName:n.method,args:n.args,__mode:"prepared"})}}async estimateGas(e){try{return{gas:await V(this.wagmiConfig,{account:e.address,to:e.to,data:e.data,type:"legacy"})}}catch(e){throw Error("WagmiAdapter:estimateGas - error estimating gas")}}parseUnits(e){return(0,ea.parseUnits)(e.value,e.decimals)}formatUnits(e){return(0,er.formatUnits)(e.value,e.decimals)}async addWagmiConnector(e){let t;if(!this.namespace)throw Error("WagmiAdapter:addWagmiConnector - namespace is required");let{enableEIP6963:n}=em.OptionsController.state||{};if(e.type===es.ConstantsUtil.CONNECTOR_ID.INJECTED&&!1===n||e.id===es.ConstantsUtil.CONNECTOR_ID.AUTH||e.id===es.ConstantsUtil.CONNECTOR_ID.WALLET_CONNECT)return;e.id!==es.ConstantsUtil.CONNECTOR_ID.BASE_ACCOUNT&&(t=await e.getProvider().catch(()=>void 0));let i=eh.AssetController.state.connectorImages;this.addConnector({id:e.id,explorerId:el.PresetsUtil.ConnectorExplorerIds[e.id]??el.PresetsUtil.ConnectorExplorerIds[e.name],imageUrl:i?.[e.id]??e.icon,name:el.PresetsUtil.ConnectorNamesMap[e.id]??e.name,imageId:el.PresetsUtil.ConnectorImageIds[e.id],type:el.PresetsUtil.ConnectorTypesMap[e.type]??"EXTERNAL",info:e.id===es.ConstantsUtil.CONNECTOR_ID.INJECTED?void 0:{rdns:e.id},provider:t,chain:this.namespace,chains:[]})}async syncConnectors(){!function(e,t){let{onChange:n}=t;e._internal.connectors.subscribe((e,t)=>{n(Object.values(e),t)})}(this.wagmiConfig,{onChange:e=>{e.forEach(e=>this.addWagmiConnector(e))}}),this.addWagmiConnectors(),await Promise.all(this.wagmiConfig.connectors.map(e=>this.addWagmiConnector(e))),await this.addThirdPartyConnectors()}async syncConnections(){let e=this.connectors.filter(e=>{let{hasDisconnected:t,hasConnected:n}=ew.HelpersUtil.getConnectorStorageInfo(e.id,this.namespace);return!t&&n}).map(e=>this.getWagmiConnector(e.id)).filter(Boolean);await (0,O.reconnect)(this.wagmiConfig,{connectors:e})}async syncConnection(e){let{id:t,chainId:n}=e,i=(0,T.getConnections)(this.wagmiConfig).find(e=>e.connector.id===t),r=this.getWagmiConnector(t),a=await r?.getProvider();if(eg.CoreHelperUtil.isSafeApp()&&t===es.ConstantsUtil.CONNECTOR_ID.SAFE&&!i?.accounts.length){let e=this.getWagmiConnector("safe");if(e){let t=await d(this.wagmiConfig,{connector:e,chainId:Number(n)}),r=await e.getProvider();return{chainId:Number(n),address:this.toChecksummedAddress(t.accounts[0]),provider:r,type:i?.connector.type?.toUpperCase(),id:i?.connector.id}}}return{chainId:Number(i?.chainId),address:this.toChecksummedAddress(i?.accounts[0]),provider:a,type:i?.connector.type?.toUpperCase(),id:i?.connector.id}}async connectWalletConnect(e){try{let t=this.getWalletConnectConnector();await t.authenticate();let n=this.getWagmiConnector("walletConnect");if(!n)throw Error("UniversalAdapter:connectWalletConnect - connector not found");let i=await d(this.wagmiConfig,{connector:n,chainId:e?Number(e):void 0});return i.chainId!==Number(e)&&await x(this.wagmiConfig,{chainId:i.chainId}),{clientId:await t.provider.client.core.crypto.getClientId()}}catch(e){if(e instanceof ei.UserRejectedRequestError||eo.ErrorUtil.isUserRejectedRequestError(e))throw new eo.UserRejectedRequestError(e);throw e}}async connect(e){try{let{id:t,address:n,provider:i,type:r,info:a,chainId:o,socialUri:s}=e,c=this.getWagmiConnector(t);if(!c)throw Error("connectionControllerClient:connectExternal - connector is undefined");i&&a&&c.id===es.ConstantsUtil.CONNECTOR_ID.EIP6963&&c.setEip6963Wallet?.({provider:i,info:a});let l=this.wagmiConfig.state?.connections?.get(c.uid);if(l){await this.wagmiConfig.storage?.setItem("recentConnectorId",c.id);let e=[...l.accounts].sort((e,t)=>ew.HelpersUtil.isLowerCaseMatch(e,n)?-1:+!!ew.HelpersUtil.isLowerCaseMatch(t,n));return this.wagmiConfig?.setState(t=>({...t,connections:new Map(t.connections).set(c.uid,{accounts:e,chainId:l.chainId,connector:l.connector}),current:c.uid,status:"connected"})),{address:this.toChecksummedAddress(e[0]),chainId:l.chainId,provider:i,type:r,id:t}}let h=await d(this.wagmiConfig,{connector:c,chainId:o?Number(o):void 0,socialUri:s}),u=i??await c.getProvider();return{address:this.toChecksummedAddress(h.accounts[0]),chainId:h.chainId,provider:u,type:r,id:t}}catch(e){if(e instanceof ei.UserRejectedRequestError||eo.ErrorUtil.isUserRejectedRequestError(e))throw new eo.UserRejectedRequestError(e);throw e}}get connections(){return Array.from(this.wagmiConfig.state.connections.values()).map(e=>({accounts:e.accounts.map(e=>({address:this.toChecksummedAddress(e)})),connectorId:e.connector.id}))}async reconnect(e){let{id:t}=e,n=this.getWagmiConnector(t);if(!n)throw Error("connectionControllerClient:connectExternal - connector is undefined");await (0,O.reconnect)(this.wagmiConfig,{connectors:[n]})}async getBalance(e){let t=e.address,n=this.getCaipNetworks().find(t=>t.id===e.chainId);if(!t)return Promise.resolve({balance:"0.00",symbol:"ETH"});if(n&&this.wagmiConfig){let t=`${n.caipNetworkId}:${e.address}`,i=this.balancePromises[t];if(i)return i;let r=eC.StorageUtil.getNativeBalanceCacheForCaipAddress(t);return r?{balance:r.balance,symbol:r.symbol}:(this.balancePromises[t]=new Promise(async i=>{try{let r=Number(e.chainId),a=await P(this.wagmiConfig,{address:e.address,chainId:r,token:e.tokens?.[n.caipNetworkId]?.address});eC.StorageUtil.updateNativeBalanceCache({caipAddress:t,balance:a.formatted,symbol:a.symbol,timestamp:Date.now()}),i({balance:a.formatted,symbol:a.symbol})}catch(e){console.warn("Appkit:WagmiAdapter:getBalance - Error getting balance",e),i({balance:"0.00",symbol:"ETH"})}}).finally(()=>{delete this.balancePromises[t]}),this.balancePromises[t]||{balance:"0.00",symbol:"ETH"})}return{balance:"",symbol:""}}getWalletConnectProvider(){return this.getWagmiConnector("walletConnect")?.provider}async disconnect(e){if(e.id){let t=this.getWagmiConnector(e.id),n=(0,T.getConnections)(this.wagmiConfig).find(t=>ew.HelpersUtil.isLowerCaseMatch(t.connector.id,e.id));return(await (0,F.disconnect)(this.wagmiConfig,{connector:t}),!1===em.OptionsController.state.enableReconnect&&this.deleteConnection(e.id),n)?{connections:[{accounts:n.accounts.map(e=>({address:this.toChecksummedAddress(e)})),connectorId:n.connector.id}]}:{connections:[]}}return this.disconnectAll()}async disconnectAll(){let e=(0,T.getConnections)(this.wagmiConfig),t=await Promise.allSettled(e.map(async e=>{let t=this.getWagmiConnector(e.connector.id);return t&&await (0,F.disconnect)(this.wagmiConfig,{connector:t}),e}));return this.wagmiConfig.state.connections.clear(),{connections:t.filter(e=>"fulfilled"===e.status).map(({value:e})=>({accounts:e.accounts.map(e=>({address:this.toChecksummedAddress(e)})),connectorId:e.connector.id}))}}async switchNetwork(e){let{caipNetwork:t}=e,n=this.wagmiConfig.chains.find(e=>e.id.toString()===t.id.toString());if(!n)throw Error("connectionControllerClient:switchNetwork - wagmiChain is undefined");let{name:i,nativeCurrency:r,rpcUrls:a,blockExplorers:o,id:s}=n,c=t.rpcUrls?.chainDefault?.http?.[0]??a.default.http[0]??"",l=o?.default.url??t.blockExplorers?.default?.url??"",d=r??t.nativeCurrency,h=i??t.name;await x(this.wagmiConfig,{chainId:s,addEthereumChainParameter:{chainName:h,nativeCurrency:d,rpcUrls:[c],blockExplorerUrls:[l]}}),await super.switchNetwork(e)}async getCapabilities(e){if(!this.wagmiConfig)throw Error("connectionControllerClient:getCapabilities - wagmiConfig is undefined");let t=(0,T.getConnections)(this.wagmiConfig)[0],n=t?this.getWagmiConnector(t.connector.id):null;if(!n)throw Error("connectionControllerClient:getCapabilities - connector is undefined");let i=await n.getProvider();if(!i)throw Error("connectionControllerClient:getCapabilities - provider is undefined");return await i.request({method:"wallet_getCapabilities",params:[e]})}async grantPermissions(e){if(!this.wagmiConfig)throw Error("connectionControllerClient:grantPermissions - wagmiConfig is undefined");let t=(0,T.getConnections)(this.wagmiConfig)[0],n=t?this.getWagmiConnector(t.connector.id):null;if(!n)throw Error("connectionControllerClient:grantPermissions - connector is undefined");let i=await n.getProvider();if(!i)throw Error("connectionControllerClient:grantPermissions - provider is undefined");return i.request({method:"wallet_grantPermissions",params:e})}async revokePermissions(e){if(!this.wagmiConfig)throw Error("connectionControllerClient:revokePermissions - wagmiConfig is undefined");let t=(0,T.getConnections)(this.wagmiConfig)[0],n=t?this.getWagmiConnector(t.connector.id):null;if(!n)throw Error("connectionControllerClient:revokePermissions - connector is undefined");let i=await n.getProvider();if(!i)throw Error("connectionControllerClient:revokePermissions - provider is undefined");return i.request({method:"wallet_revokePermissions",params:e})}async walletGetAssets(e){if(!this.wagmiConfig)throw Error("connectionControllerClient:walletGetAssets - wagmiConfig is undefined");let t=(0,T.getConnections)(this.wagmiConfig)[0],n=t?this.getWagmiConnector(t.connector.id):null;if(!n)throw Error("connectionControllerClient:walletGetAssets - connector is undefined");let i=await n.getProvider();if(!i)throw Error("connectionControllerClient:walletGetAssets - provider is undefined");return i.request({method:"wallet_getAssets",params:[e]})}setAuthProvider(e){if(!this.namespace)throw Error("WagmiAdapter:setAuthProvider - namespace is required");this.addConnector({id:es.ConstantsUtil.CONNECTOR_ID.AUTH,type:"AUTH",name:es.ConstantsUtil.CONNECTOR_NAMES.AUTH,provider:e,imageId:el.PresetsUtil.ConnectorImageIds[es.ConstantsUtil.CONNECTOR_ID.AUTH],chain:this.namespace,chains:[]})}async setUniversalProvider(e){e.on("connect",()=>{let e=(0,T.getConnections)(this.wagmiConfig),t=this.getWagmiConnector("walletConnect");if(t&&!e.find(e=>e.connector.id===t.id)){if("eip155"===eu.ChainController.state.activeChain)return;(0,O.reconnect)(this.wagmiConfig,{connectors:[t]})}});let t=eP({universalProvider:e});return this.configureInternalConnector(t),this.addConnector(new ep.WalletConnectConnector({provider:e,caipNetworks:this.getCaipNetworks(),namespace:"eip155"})),Promise.resolve()}toChecksummedAddress(e){return(0,j.checksumAddress)(e.toLowerCase())}}let eD="489f021a5262316c1c25ee1ac1cd50cb",eH=new ej({networks:[o.mainnet,s.polygon,a.arbitrum],projectId:eD||"placeholder"});function eq({children:e}){return(0,n.jsx)(i.WagmiProvider,{config:eH.wagmiConfig,children:e})}(0,c.createAppKit)({adapters:[eH],networks:[o.mainnet,s.polygon,a.arbitrum],projectId:eD||"placeholder",metadata:{name:"Gravii",description:"Behavioral Analytics for Web3",url:window.location.origin,icons:["https://gravii.io/icon.png"]},features:{analytics:!1,email:!1,socials:!1,emailShowWallets:!0},enableWallets:!0}),e.s(["Web3Provider",()=>eq],781690)},659503,e=>{e.n(e.i(781690))}]);